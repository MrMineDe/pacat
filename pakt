#!/bin/sh

# maybe there is a better approach, but this allows for easy use in if statement without [] aka test command, which results in problems
stringNotContain() { case $1 in *$2* ) return 1;; *) return 0;; esac ;}

# save all the packages for a group of categories temporarily in /tmp
# This is needed, because we allow different categories for different packages
# We could do this with an array of some sort, but would lose POSIX-compliancy
pkg_tempsave() {
	for c in $(echo $CAT | tr ' ' '\n'); do
		for p in "$PAC"; do
			echo "CAT:$c"
			echo "PKG:$p"
			echo $p >> /tmp/pakt/$c
		done
	done
	echo test

	PAC=""
	CAT="$DEFAULT_CATEGORIES"
}

# TODO DECIDE if we want a short flag like -h and overwrite the pacman flag
if [ "$#" -eq 0 ] || [ "$1" = "--pakt-help" ]; then
	echo "Pakt (PAcman KaTegories) - Pacman wrapper for categorizing packages

Usage: pakt (pacman/aur helper flags) package ... [+category] ...
    or pakt --help
    or pakt -h

Examples:
    # Just use pakt as a pacman/AUR helper wrapper
    pakt -S neovim

    # Installs neovim and assigns it to the \"editors\" category
    pakt -S neovim +editors

    # Performs system update, installs htop and lf both in the \"cli\" category,
    # firefox in \"basic\" but git in none
    pakt -Syu htop lf +cli firefox +basic git"

	exit
fi

# Source the config file
# TODO DECIDE if there is no config, we should copy the default config as configfile and load that instead of defining it here
# Define the location where we search for the config file
ACTIVATE_DEF_CONF=0
if [ -z "$PAKT_CONFIG_PATH" ]; then
	if [ -z "$XDG_CONFIG_HOME" ]; then
		CONF_PATH="$XDG_CONFIG_HOME/pakt/pakt.conf"
	else
		CONF_PATH="$HOME/.config/pakt/pakt.conf"
	fi
else
	CONF_PATH="$PAKT_CONFIG_PATH"
fi
# Now check if config file is there and load it
if [ -e "$CONF_PATH" ]; then
	. "$CONF_PATH"
else
	ACTIVATE_DEF_CONF=1
fi

if [ $ACTIVATE_DEF_CONF -eq 1 ]; then
	CAT="default"
	CMD="pacman"
	if [ -z "$XDG_DATA_HOME" ]; then
		PTH="$HOME/.local/share/pakt"
	else
		PTH="$XDG_DATA_HOME/pakt"
	fi
	MODE=""
else
	# shorten the config variable names
	CMD="$PACKAGE_MANAGER"
	CAT="$DEFAULT_CATEGORIES"
	PTH="$PAKT_PATH"
fi

PAC=""
SYNC=0
ARG_WAS_CAT=0

# we need this dir in pkg_tempsave()
mkdir -p /tmp/pakt

# This is used, to save the state of -C argument, to store the ARG after -C
DASH_C_TRUE=0
for A in "$@"; do
	if [ "$DASH_C_TRUE" -eq 1 ]; then
		CAT="${CAT} ${A}"
		DASH_C_TRUE=0
		continue;
	fi
	case "$A" in
		-*)
			case "$A" in
				*S*)
					MODE="S"
					CMD="${CMD} ${A}"
				;;
				*R*)
					MODE="R"
					CMD="${CMD} ${A}"
				;;
				# TODO refactor this to a seperate script
				"-ABC")
					SYNC=1
				;;
				*)
					CMD="${CMD} ${A}"
				;;
			esac
		;;
		"+"*)
			CAT="${CAT} ${A#+}"
			# ARG_WAS_CAT is used to detect, when a package is declared after a category.
			# When that happens we want to first save the packages before to the categories before and then reset both.
			ARG_WAS_CAT=1
		;;
		*)
			if [ $ARG_WAS_CAT -eq 1 ]; then
				pkg_tempsave
				ARG_WAS_CAT=0
			fi
			CMD="${CMD} ${A}"
			PAC="${PAC} ${A}"
		;;
	esac
done

# If -C is the last argument, throw an error!
if [ "$DASH_C_TRUE" -eq 1 ]; then
	echo "Syntax: -C ARG ; -C needs one argument! See pakt --pakt-help for more info"
	exit
fi

# Also save the last packages
pkg_tempsave

# Execute pacman
if [ $SYNC -eq 0 ]; then
	if ! $CMD ; then
		echo "Pacman returned a fail. Exiting..."
		exit
	fi
# NOTE: This is broken by this commit. But we want to move this to a seperate script anyway, so idc
else # -ABC, sync the packages
	PAC_DEL=$(sudo $CMD -Qeq)
	PAC_BASE=$(sudo $CMD -Qq)
	PAC_ADD=""
	# We want to combine all the categoriyfiles we got as parameter
	for c in $CAT; do
		# We unfortunately have to do this for every entry in every categoryfile...
		while read -r p; do
			# PAC_DEL should include all packages implicitly installed on the system by the user that are not in the categoryfiles
			PAC_DEL=$(echo "$PAC_DEL" | tr ' ' '\n' | grep -v "^$p\$")
			# PAC_ADD should include all packages of the categoryfiles, that are not installed on the system
			if stringNotContain "$(echo "$PAC_BASE" | tr '\n' ' ')" " $p "; then
				PAC_ADD="${PAC_ADD} ${p}"
			fi
		done < "$PTH/$c"
	done
	# We convert spaces to new lines for grep a few lines ago, for pacman we need to reverse that
	PAC_DEL=$(echo "$PAC_DEL" | tr '\n' ' ')
	# We want to install/remove all the packages specified in the command as well
	if [ -n "$PAC" ] && [ "$MODE" = "S" ]; then
		PAC_ADD="${PAC_ADD} ${PAC}"
	fi
	if [ -n "$PAC" ] && [ "$MODE" = "R" ]; then
		PAC_DEL="${PAC_DEL} ${PAC}"
	fi
	# If there are any packages that would get installed and uninstalled, we need to throw an error
	# TODO DECIDE if we really need to throw an error or rather handle it differently
	for p in $PAC_DEL; do
		if ! stringNotContain "$(echo "$PAC_ADD" | tr '\n' ' ')" " $p "; then
			  echo "Invalid arguments! You would install and remove $p! Exiting..."
			  exit
		fi
	done
	# To be safe, we print the Packages to remove and install before calling pacman
	if [ -n "$PAC_DEL" ]; then
		echo "Removing(dependencies not listed): $PAC_DEL"
	fi
	if [ -n "$PAC_ADD" ]; then
		echo "Installing: $PAC_ADD"
	fi
	# Finally sync the packages
	# TODO Decide if sync should also do a full system upgrade.
	# This would also reduce the danger of partial upgrades/corrupt packages etc.
	if [ -n "$PAC_DEL" ]; then
		if ! sudo pacman -Rs $PAC_DEL; then
			echo "Pacman returned a fail. Exiting..."
			exit
		fi
	fi
	if [ -n "$PAC_ADD" ]; then
		if ! sudo pacman -Sy $PAC_ADD; then
			echo "Pacman returned a fail. Exiting..."
			exit
		fi
	fi
fi

# Check if a Mode we care about was used. Otherwise the package manager was propably used to perform some other non-installing/removing action we dont care about
if [ -z $MODE ]; then
	exit;
fi

# Create path if it doesnt exist
mkdir -p "$PTH"
for f in /tmp/pakt/*; do
	# we dont want f to be /tmp/pakt/filename, but rather only filename
	f=$(basename $f)
	# This will make sure, that there are no error messages about a categoryfile not existing
	# These errors are not fatal, but the user should not see them!
	touch "$PTH/$f"
	cat "/tmp/pakt/$f"
	for p in $(cat /tmp/pakt/$f); do
		case $MODE in
			S) # Add Package
				# Check if Package is already in file, then dont add it
				if [ "$p" != "$(grep "^$p\$" "$PTH/$f")" ]; then
					echo "$p" >> "$PTH/$f"
				fi
				;;
			R) # Remove Package
				sed -n "/^$p\$/"'!'"p" "$PTH/$f" | tee "$PTH/$f" > /dev/null # You cant pipe directly into PTH/f bc the pipe is opened first, therefor the file is beeing cleared, therefor sed opens a empty file
				;;
		esac
	done
done

# At last we want to clean up, so we dont work on the packages from last time
rm /tmp/pakt -r
