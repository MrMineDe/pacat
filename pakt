#!/bin/sh
# Pakt (PAcman KaTegories) - Pacman wrapper for categorizing packages
# v0.0.1 GPL-2.0
# https://github.com/mrminede/pakt

# Save all the packages for a group of categories temporarily in /tmp.
# This is needed, because we allow different categories for different packages.
# We could do this with an array of some sort, but would lose POSIX-compliancy.
pkg_tempsave() {
	for c in $(echo "$CAT" | tr ' ' '\n'); do
		for p in $PKGS; do
			echo "$p" >> /tmp/pakt/"$c"
		done
	done

	PKGS=""
	CAT="$DEFAULT_CATEGORIES"
}

# Strict mode. The script will throw an error on an unbound variable encounter.
set -u

# Temporary path storing new package and category data.
mkdir -p /tmp/pakt

# Check whether the data path was defined with XDG.
if [ -z "${XDG_DATA_HOME:-}" ]; then
	DATA_PATH="$HOME/.local/share/pakt"
else
	DATA_PATH="$XDG_DATA_HOME/pakt"
fi
mkdir -p "$DATA_PATH"

# Control/set config path variable.
if [ -z "${PAKT_CONF_PATH:-}" ]; then
	PAKT_CONF_PATH="/etc/pakt.conf"
fi

# Create new pakt.conf if none exists.
if [ ! -e "$PAKT_CONF_PATH" ]; then
	echo "PAKT: ERROR: /etc/pakt.conf not found."
	exit 1
fi

. "$PAKT_CONF_PATH"

# Process variables
CMD="$PACKAGE_MANAGER"
CAT="$DEFAULT_CATEGORIES"

PKGS=""
TRANSACTION_READY=1

# Help message part.
if [ "${1:-}" = "--help" ]; then
	echo "PAKT: Displaying your package manager's help message.
If you wanted to see pakt, see the manpage at \`man pakt\`
"
fi

for arg in "$@"; do
	case "$arg" in
		-*)
			CMD="${CMD} ${arg}"
			;;
		"+"*)
			# Split up comma-separated categories (+cat1,cat2,test,cli).
			arg=$(echo "$arg" | tr ',' ' ')
			CAT="${CAT} ${arg#+}"

			# This is used to detect, when a package is declared after a category.
			# When that happens we want to first save the package and categoriy data before resetting both.
			TRANSACTION_READY=0
			;;
		*)
			# See comment above.
			if [ $TRANSACTION_READY -eq 0 ]; then
				pkg_tempsave
				TRANSACTION_READY=1
			fi

			CMD="${CMD} ${arg}"
			PKGS="${PKGS} ${arg}"
			;;
	esac
done

# Save the last packages.
pkg_tempsave

# Execute pacman.
if ! $CMD ; then
	echo "PAKT: ERROR: Package manager returned a fail. Exiting..."
	exit 1
fi

# Omits the rest of the script if no category tomfoolery was performed.
if [ ! "$(ls /tmp/pakt)" ]; then
	exit
fi

# Introduce the REMOVE_MODE variable if we're dealing with a remove transaction.
# We don't just check the second/third argument for '-R' because, apparently, you can place the flag anywhere.
# `sudo pacman neovim htop -Rns` is legal. :skull:
if echo "$CMD" | grep -q "\-R"; then
	REMOVE_MODE=""
fi

for tmpfile in /tmp/pakt/*; do
	catfile=$DATA_PATH/`basename $tmpfile`
	touch $catfile

	for pkg in $(cat "$tmpfile"); do
		if [ -e "${REMOVE_MODE:-}" ]; then
			# Remove package from category file.
			# You can't pipe directly into tmpfile because it would encounter an empty file.
			sed -n "/^$pkg\$/"'!'"p" "$catfile" | tee "$catfile" > /dev/null
		elif [ "$pkg" != "$(grep "^$pkg\$" "$catfile")" ]; then
			# Add package to category file, if not already there.
			echo "$pkg" >> "$catfile"
		fi
	done
done

# At last we want to clean up, so we don't work on the packages from last time.
rm -r "/tmp/pakt"
