#!/bin/sh
# Pakt (PAcman KaTegories) - Pacman wrapper for categorizing packages
# v0.0.1 GPL-2.0
# https://github.com/mrminede/pakt

# Help message part.
if [ "$#" -eq 0 ] || [ "${1:-}" = "--help" ] || [ "${1:-}" = "-h" ]; then
	echo "PAKT: shamelessly redirecting you to the manpage ..."
	sleep 3
	man pakt-dry
	exit
fi

# Process variables
FLAG=""
REST=""
CATS="$DEFAULT_CATEGORIES"
TRANSACTION_READY=1

# Save all the packages for a group of categories temporarily in /tmp.
# This is needed, because we allow different categories for different packages.
# We could do this with an array of some sort, but would lose POSIX-compliancy.
# TODO
pkg_tempsave() {
	for c in $(echo "$CATS" | tr ' ' '\n'); do
		for p in $PKGS; do
			echo "$p" >> /tmp/pakt-dry/"$c"
		done
	done

	PKGS=""
	CATS="$DEFAULT_CATEGORIES"
}

# Strict mode. The script will throw an error on an unbound variable encounter.
set -u

# Temporary path storing new package and category data.
# TODO
mkdir -p /tmp/pakt-dry

# Check whether the data path was defined with XDG.
if [ -z "${XDG_DATA_HOME:-}" ]; then
	DATA_PATH="$HOME/.local/share/pakt"
else
	DATA_PATH="$XDG_DATA_HOME/pakt"
fi
mkdir -p "$DATA_PATH"

# Control/set config path variable.
if [ -z "${PAKT_CONF_PATH:-}" ]; then
	PAKT_CONF_PATH="/etc/pakt.conf"
fi

# Create new pakt.conf if none exists.
if [ ! -e "$PAKT_CONF_PATH" ]; then
	echo "PAKT: ERROR: /etc/pakt.conf not found."
	exit 1
fi

. "$PAKT_CONF_PATH"

for arg in "$@"; do
	case "$arg" in
		-*)
			if [ -n "$FLAG" ]; then
				"PAKT: ERROR: pakt only takes one flag. Exiting ..."
				exit 1
			fi
			FLAG="$arg"
			;;
		*)
			REST="${REST} ${arg}"
	esac
done

case "$FLAG" in
	"")
		# TODO PLAN
		# show pkgs for argument
		# normal argument is a file path
		for arg in $(echo "$REST" | tr ' ' '\n'); do
			echo "TODO TEST catting $arg"
			case "$arg" in
				"+"*)
					cat $DATA_PATH/${arg#+}
					;;
				*)
					cat "$arg"
					;;
			esac
		done
		;;
	"-a")
		# TODO PLAN
		# dry-adds categories just like in pakt
		;;
	"-r")
		# TODO PLAN
		# dry-removes categories just like in pakt
		;;
esac

# Save the last packages.
pkg_tempsave

# TODO NOTE dont keep it if there is a special action for no arguments
# Omits the rest of the script if no category tomfoolery was performed.
if [ ! "$(ls /tmp/pakt-dry)" ]; then
	exit
fi

for tmpfile in /tmp/pakt-dry/*; do
	catfile=$DATA_PATH/`basename $tmpfile`
	touch $catfile

	for pkg in $(cat "$tmpfile"); do
		if [ -e "${REMOVE_MODE:-}" ]; then
			# Remove package from category file.
			# You can't pipe directly into tmpfile because it would encounter an empty file.
			sed -n "/^$pkg\$/"'!'"p" "$catfile" | tee "$catfile" > /dev/null
		elif [ "$pkg" != "$(grep "^$pkg\$" "$catfile")" ]; then
			# Add package to category file, if not already there.
			echo "$pkg" >> "$catfile"
		fi
	done
done

# At last we want to clean up, so we don't work on the packages from last time.
rm -r /tmp/pakt-dry
